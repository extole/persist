// $Id$

package net.sf.persist.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import net.sf.persist.writer.VoidWriter;
import net.sf.persist.writer.Writer;

/**
 * Defines column mapping for a given field. Must be added to a getter or a
 * setter of the field being mapped.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Column {

    /**
     * Name of the column mapped to the field.
     */
    String name() default ""; // a @Column annotation can leave name undefined, since it may be only concerned with autoGenerated

    /**
     * If the field is auto-generated in the database (eg. auto increment
     * fields). This will hint the engine to avoid using the field in
     * insert/update automatic operations, and to let it know which fields must
     * be updated if updateAutoGeneratedKeys is set to true.
     */
    boolean autoGenerated() default false;

    /**
     * If the field is a primary key in the database and should be used in the where clause for updates, deletes,
     * and reading by primary key.
     */
    boolean primaryKey() default false;

    /**
     * If the getter/setter use optional values, the sub-type must be explicitly stated due to Java's generic
     * subtype handling.
     */
    Class<?> optionalSubType() default Void.class;

    /**
     * When using a custom, strongly-typed return type, the serialization type for table I/O must be declared.
     * For standard serialization types, this does not need to be set, but note that, when reading/writing the
     * table, setting this serialization type will override the getter/setter type corresponding to the field.
     */
    Class<?> serializeAs() default Void.class;

    /**
     * For a custom type, a writer class (extending net.sf.persist.writer.Writer) must be created and referenced
     * here, which specifies how to convert a custom type to/from a serialization type.
     */
    Class<? extends Writer> writerClass() default VoidWriter.class;
}
